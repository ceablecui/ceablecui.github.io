---
layout: post
title:  "Android ORMLite入门教程"
date:   2016-06-01 16:45:35
categories: android

---

# Android ORMLite入门 #

## 0. 前言

还在使用ORMLite的人好像不多了，接触它是因为之前参与的一个项目立项很早，组长当时定了用ORMLite，所以就一直用下来了，算是历史遗留问题吧。

在这里写一篇关于ORMLite的文章，一是为了总结ORMLite的基本用法，以备之后不时之需；二是因为在之前开发的过程中，很多东西都是现查现用，至于这些方法背后的实现方式和思想都没有研究过，只是一知半解，现在回过头来重新学习一下ORMLite，加深一下理解；最后，如果还有同学不幸需要处理和我类似的“历史遗留问题”，希望这篇文章能够对你有帮助。

## 1. ORMLite简介

ORMLite官网对于ORMLite-Android的介绍： 

[http://ormlite.com/sqlite_java_android_orm.shtml](http://ormlite.com/sqlite_java_android_orm.shtml).

ORMLite Android Example Code: 

[https://github.com/j256/ormlite-examples/tree/master/android](https://github.com/j256/ormlite-examples/tree/master/android). 

(Example Code已经很久没更新了，最近一次提交是一年前，而且项目还是在eclipse上的)

ORMLite Android的源码：

[https://github.com/j256/ormlite-android](https://github.com/j256/ormlite-android). 

(源码倒是一直在更新)

## 2. 下载ORMLite Jar包

由于Android系统缺少官方对JDBC的支持，ORMLite直接通过请求Android系统数据库的APIs访问SQLite数据库。因此在使用ORMLite时，我们应确保工程中引用了ormlite-core.jar和ormlite-android.jar两个Jar包。

在官网的发布页面( [http://ormlite.com/releases/](http://ormlite.com/releases/) )下载ormlite-android-x.xx.jar和ormlite-core-x.xx.jar两个Jar包，并导入工程。

## 3. 创建类

### 3.1 添加ORMLite注解

{% highlight java linenos %}
/**
 * A simple demonstration object we are creating and persisting to the database.
 */
@DatabaseTable(tableName = "simpledata")
public class SimpleData {

	// id is generated by the database and set on the object automagically
	@DatabaseField(generatedId = true)
	int id;
	@DatabaseField(index = true)
	String string;
	@DatabaseField
	long millis;
	@DatabaseField
	Date date;
	@DatabaseField
	boolean even;

	SimpleData() {
		// needed by ormlite
	}
}
{% endhighlight %}

以上代码定义了一个SimpleData类，其中 `@DatabaseTable(tableName = "simpledata")` 表示SimpleData类对应数据库中的"simpledata"表，我们也可以不写 `@DatabaseTable(tableName = "simpledata")` 这段声明，这样ORMLite将会把类名作为表名（ `@DatabaseTable` 可用 `@Entity` 代替）。

而类中的成员变量若要存储在数据库中，那么必须在声明成员变量前添加 `@DatabaseField` 注解，否则数据库中对应的表将不会生成与该成员变量对应的字段（ `@DatabaseField` 可用 `@Column` 代替）。

`@DatabaseField` 可以设置数据库中字段的属性，常用属性如下：

* `columnName`：设定数据库中对应字段的名称，若不指定则默认为变量名
* `dataType`：设定字段类型
* `defaultValue`：当表中插入数据时，该字段的默认值
* `width`：字段的长度，常用于String字段。默认为0，即根据字段类型和数据库默认值设定长度，String类型默认为255个字符
* `canBeNull`：是否允许为空
* `id`：设定当前字段是否为id，默认为false。在一个类中只有一个成员变量可以设置为id。id是每条数据的唯一标识。
* 其他属性可参见[ORMLite Package](http://ormlite.com/docs/ormlite.pdf)的2.1章节。



### 3.2 添加空构造方法

在给类和成员变量添加完注解后，ORMLite要求你需要在类中添加一个空构造方法，这个构造方法必须是至少在包内可见的。因为当使用ORMLite查询数据库时，ORMLite将查询结果使用Java反射机制构造并返回给用户，此时类内的构造方法需要被调用。

# 4. 创建DatabaseHelper

{% highlight java linenos %}
/**
 * Database helper class used to manage the creation and upgrading of your database. This class also usually provides
 * the DAOs used by the other classes.
 */
public class DatabaseHelper extends OrmLiteSqliteOpenHelper {

	// name of the database file for your application -- change to something appropriate for your app
	private static final String DATABASE_NAME = "helloAndroid.db";
	// any time you make changes to your database objects, you may have to increase the database version
	private static final int DATABASE_VERSION = 1;

	// the DAO object we use to access the SimpleData table
	private Dao<SimpleData, Integer> simpleDao = null;
	private RuntimeExceptionDao<SimpleData, Integer> simpleRuntimeDao = null;

	public DatabaseHelper(Context context) {
		super(context, DATABASE_NAME, null, DATABASE_VERSION, R.raw.ormlite_config);
	}

	/**
	 * This is called when the database is first created. Usually you should call createTable statements here to create
	 * the tables that will store your data.
	 */
	@Override
	public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {
		try {
			Log.i(DatabaseHelper.class.getName(), "onCreate");
			TableUtils.createTable(connectionSource, SimpleData.class);
		} catch (SQLException e) {
			Log.e(DatabaseHelper.class.getName(), "Can't create database", e);
			throw new RuntimeException(e);
		}

		// here we try inserting data in the on-create as a test
		RuntimeExceptionDao<SimpleData, Integer> dao = getSimpleDataDao();
		long millis = System.currentTimeMillis();
		// create some entries in the onCreate
		SimpleData simple = new SimpleData(millis);
		dao.create(simple);
		simple = new SimpleData(millis + 1);
		dao.create(simple);
		Log.i(DatabaseHelper.class.getName(), "created new entries in onCreate: " + millis);
	}

	/**
	 * This is called when your application is upgraded and it has a higher version number. This allows you to adjust
	 * the various data to match the new version number.
	 */
	@Override
	public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {
		try {
			Log.i(DatabaseHelper.class.getName(), "onUpgrade");
			TableUtils.dropTable(connectionSource, SimpleData.class, true);
			// after we drop the old databases, we create the new ones
			onCreate(db, connectionSource);
		} catch (SQLException e) {
			Log.e(DatabaseHelper.class.getName(), "Can't drop databases", e);
			throw new RuntimeException(e);
		}
	}

	/**
	 * Returns the Database Access Object (DAO) for our SimpleData class. It will create it or just give the cached
	 * value.
	 */
	public Dao<SimpleData, Integer> getDao() throws SQLException {
		if (simpleDao == null) {
			simpleDao = getDao(SimpleData.class);
		}
		return simpleDao;
	}

	/**
	 * Returns the RuntimeExceptionDao (Database Access Object) version of a Dao for our SimpleData class. It will
	 * create it or just give the cached value. RuntimeExceptionDao only through RuntimeExceptions.
	 */
	public RuntimeExceptionDao<SimpleData, Integer> getSimpleDataDao() {
		if (simpleRuntimeDao == null) {
			simpleRuntimeDao = getRuntimeExceptionDao(SimpleData.class);
		}
		return simpleRuntimeDao;
	}

	/**
	 * Close the database connections and clear any cached DAOs.
	 */
	@Override
	public void close() {
		super.close();
		simpleDao = null;
		simpleRuntimeDao = null;
	}
}
{% endhighlight %}

在Android系统上使用ORMLite时，我们需要创建自己的 `DatabaseHelper` （应继承于 `OrmLiteSqliteOpenHelper` 类）， `DatabaseHelper` 在程序安装时create或upgrades数据库，并提供了一个DAO供程序操作数据库使用。自己创建的 `DatabaseHelper` 需要实现父类的 `onCreate()`和 `onUpgrade()` 方法。

我们可以创建一个类，使用静态方法创建一个 `DatabaseHelper` 并在App运行时保持 `DatabaseHelper` 打开，这样可以随时访问数据库。然而，如果有多个线程同时连接到数据库进行操作，那么有可能会出现不可预料的问题。因此，ORMLite的文档推荐当我们需要连接数据库时再去使用 `OpenHelperManager` 去创建一个 `DatabaseHelper` ，当使用完成后释放。

ORMLite提供了`OrmLiteBaseActivity`，`OrmLiteBaseListActivity`，`OrmLiteBaseService`和`OrmLiteBaseTabActivity`四个基本组件，若程序中的activity或service继承于这四种组件中的某一个，那么可以在activity或service中直接调用 `getHelper()` 方法去访问 `DatabaseHelper` ， `DatabaseHelper` 会由ORMLite提供的组件在 `onCreate()` 方法中创建，并在 `OnDestroy()` 中释放。

如果我们并不想继承ORMLite提供的组件，那么我们需要自己完成以上的步骤，即在需要使用数据库时调用 `OpenHelperManager.getHelper()` 方法，在访问数据库完成后调用 `OpenHelperManager.release()` 方法。如下所示：

{% highlight java linenos %}
private DatabaseHelper databaseHelper = null;
@Override
protected void onDestroy() {
	super.onDestroy();
	if (databaseHelper != null) {
		OpenHelperManager.releaseHelper();
		databaseHelper = null;
	}
}
private DBHelper getHelper() {
	if (databaseHelper == null) {
		databaseHelper =
		OpenHelperManager.getHelper(this, DatabaseHelper.class);
	}
	return databaseHelper;
}
{% endhighlight %}

**注意**:对于任何后台线程中对于数据库的操作，一定要正确的调用e `OpenHelperManager.getHelper()`和`release()`方法，否则将会报错。

至此，通过DatabaseHelper获取到DAO后，我们已经可以使用ORMLite提供的方法进行简单的CURD操作了，ORMLite提供CURD方法主要有：

* `create` 新增数据
* `createIfNotExists` 若不存在则新增
* `createOrUpdate` 新增或修改
* `queryForId` 根据id查询
* `update` 修改
* `delete` 删除
* `queryBuilder()` 自定义查询语句
* `deleteBuilder()` 自定义删除
* `updateBuilder()` 自定义修改

在比较大的项目中，可能需要频繁使用 `queryBuilder()` 生成较为复杂的查询语句，因此我们需要根据需求创建自定义的DAO类，封装好较常使用的方法，具体内容将会在下一篇文章介绍。

本篇文章的代码来自于ORMLite提供的Sample Code，源码在[https://github.com/j256/ormlite-examples/tree/master/android/HelloAndroid](https://github.com/j256/ormlite-examples/tree/master/android/HelloAndroid)。

文章中如果有什么问题，请随时批评指正。

欢迎转载，转载请注明出处。




